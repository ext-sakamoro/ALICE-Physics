// ALICE-Physics WebAssembly 3D Viewer
// Three.js + WASM deterministic physics visualization
//
// Author: Moroya Sakamoto

import * as THREE from 'three';

// WASM types (generated by wasm-pack)
interface AlicePhysicsWasm {
  default: () => Promise<void>;
  WasmPhysicsWorld: new () => WasmPhysicsWorld;
  alicePhysicsVersion: () => string;
}

interface WasmPhysicsWorld {
  addDynamicBody(x: number, y: number, z: number, mass: number): number;
  addStaticBody(x: number, y: number, z: number): number;
  bodyCount(): number;
  step(dt: number): void;
  getPositions(): Float64Array;
  getRotations(): Float64Array;
  applyImpulse(bodyId: number, ix: number, iy: number, iz: number): void;
  setRestitution(bodyId: number, r: number): void;
  setGravity(x: number, y: number, z: number): void;
  getBodyType(bodyId: number): number;
}

// ============================================================================
// Constants
// ============================================================================

const SPHERE_RADIUS = 0.5;
const GROUND_SIZE = 50;
const DT = 1 / 60;
const BODY_COLORS: number[] = [
  0x7ab4ff, 0xff7a7a, 0x7aff7a, 0xffff7a, 0xff7aff,
  0x7affff, 0xffa07a, 0xa07aff, 0x7affa0, 0xffd700,
];

// ============================================================================
// State
// ============================================================================

let world: WasmPhysicsWorld | null = null;
let paused = false;
let frameCount = 0;
let lastFpsTime = performance.now();
let lastFps = 0;

// Three.js objects
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
const renderer = new THREE.WebGLRenderer({ antialias: true });
const meshes: THREE.Mesh[] = [];

// Shared geometry and materials
const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 16, 12);
const groundGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x222233,
  roughness: 0.8,
  metalness: 0.2,
});

// ============================================================================
// HUD Elements
// ============================================================================

const elBodyCount = document.getElementById('body-count')!;
const elFps = document.getElementById('fps')!;
const elStepTime = document.getElementById('step-time')!;
const elVersion = document.getElementById('version')!;

// ============================================================================
// Scene Setup
// ============================================================================

function setupScene(): void {
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  document.body.prepend(renderer.domElement);

  // Background
  scene.background = new THREE.Color(0x0a0a0f);
  scene.fog = new THREE.Fog(0x0a0a0f, 40, 120);

  // Camera
  camera.position.set(15, 12, 20);
  camera.lookAt(0, 3, 0);

  // Lights
  const ambient = new THREE.AmbientLight(0x334466, 0.6);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
  dirLight.position.set(10, 20, 10);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 60;
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  scene.add(dirLight);

  const pointLight = new THREE.PointLight(0x7ab4ff, 0.5, 50);
  pointLight.position.set(-5, 10, -5);
  scene.add(pointLight);

  // Ground plane
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = 0;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid helper
  const grid = new THREE.GridHelper(GROUND_SIZE, GROUND_SIZE, 0x333355, 0x1a1a2e);
  grid.position.y = 0.01;
  scene.add(grid);

  // Window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// ============================================================================
// Body Management
// ============================================================================

function createBodyMesh(colorIndex: number): THREE.Mesh {
  const color = BODY_COLORS[colorIndex % BODY_COLORS.length];
  const mat = new THREE.MeshStandardMaterial({
    color,
    roughness: 0.3,
    metalness: 0.6,
    emissive: color,
    emissiveIntensity: 0.1,
  });
  const mesh = new THREE.Mesh(sphereGeo, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

function addBody(): void {
  if (!world) return;
  const x = (Math.random() - 0.5) * 8;
  const y = 8 + Math.random() * 10;
  const z = (Math.random() - 0.5) * 8;
  const mass = 0.5 + Math.random() * 2;

  const id = world.addDynamicBody(x, y, z, mass);
  world.setRestitution(id, 0.4 + Math.random() * 0.4);

  const mesh = createBodyMesh(id);
  mesh.position.set(x, y, z);
  meshes.push(mesh);
}

function addRain(count: number): void {
  for (let i = 0; i < count; i++) {
    addBody();
  }
}

function impulseAll(): void {
  if (!world) return;
  const n = world.bodyCount();
  for (let i = 0; i < n; i++) {
    if (world.getBodyType(i) === 0) {
      const ix = (Math.random() - 0.5) * 20;
      const iy = 10 + Math.random() * 15;
      const iz = (Math.random() - 0.5) * 20;
      world.applyImpulse(i, ix, iy, iz);
    }
  }
}

function resetWorld(): void {
  if (!world) return;
  // Remove all meshes
  for (const mesh of meshes) {
    scene.remove(mesh);
    (mesh.material as THREE.MeshStandardMaterial).dispose();
  }
  meshes.length = 0;

  // Recreate world
  world = new (world.constructor as new () => WasmPhysicsWorld)();
  world.setGravity(0, -9.81, 0);

  // Add initial ground body (static)
  world.addStaticBody(0, -1, 0);
}

// ============================================================================
// Simulation Loop
// ============================================================================

function syncMeshes(): void {
  if (!world) return;
  const positions = world.getPositions();
  const n = world.bodyCount();

  // Skip body 0 (static ground) â€” meshes start from dynamic bodies
  for (let i = 0; i < meshes.length; i++) {
    const bodyIdx = i + 1; // offset by 1 for static ground
    if (bodyIdx < n) {
      const base = bodyIdx * 3;
      meshes[i].position.set(
        positions[base],
        positions[base + 1],
        positions[base + 2],
      );
    }
  }
}

function animate(): void {
  requestAnimationFrame(animate);

  if (!paused && world) {
    const t0 = performance.now();
    world.step(DT);
    const stepMs = performance.now() - t0;
    elStepTime.textContent = stepMs.toFixed(2);
  }

  syncMeshes();

  // Simple orbit camera
  const t = performance.now() * 0.0001;
  camera.position.x = Math.cos(t) * 25;
  camera.position.z = Math.sin(t) * 25;
  camera.position.y = 12;
  camera.lookAt(0, 3, 0);

  renderer.render(scene, camera);

  // FPS counter
  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime >= 1000) {
    lastFps = frameCount;
    frameCount = 0;
    lastFpsTime = now;
    elFps.textContent = String(lastFps);
  }

  // Body count
  if (world) {
    elBodyCount.textContent = String(world.bodyCount());
  }
}

// ============================================================================
// Button Handlers
// ============================================================================

function setupControls(): void {
  document.getElementById('btn-add')!.addEventListener('click', addBody);
  document.getElementById('btn-rain')!.addEventListener('click', () => addRain(50));
  document.getElementById('btn-impulse')!.addEventListener('click', impulseAll);
  document.getElementById('btn-reset')!.addEventListener('click', resetWorld);
  document.getElementById('btn-pause')!.addEventListener('click', () => {
    paused = !paused;
    document.getElementById('btn-pause')!.textContent = paused ? 'Resume' : 'Pause';
  });
}

// ============================================================================
// WASM Initialization
// ============================================================================

async function init(): Promise<void> {
  setupScene();
  setupControls();

  try {
    // Dynamic import of WASM module (built by wasm-pack)
    const wasm = await import('../pkg/alice_physics.js') as unknown as AlicePhysicsWasm;
    await wasm.default();

    // Display version
    elVersion.textContent = wasm.alicePhysicsVersion();

    // Create physics world
    world = new wasm.WasmPhysicsWorld();
    world.setGravity(0, -9.81, 0);

    // Add static ground body
    world.addStaticBody(0, -1, 0);

    // Add initial bodies
    addRain(10);

    console.log('[ALICE-Physics] WASM initialized, version:', wasm.alicePhysicsVersion());
  } catch (e) {
    console.error('[ALICE-Physics] Failed to load WASM module:', e);
    elVersion.textContent = 'WASM ERROR';

    // Fallback: show scene without physics
    console.log('[ALICE-Physics] Running in visual-only mode (no physics)');
  }

  animate();
}

init();
